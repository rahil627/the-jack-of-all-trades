package {		import flash.display.Bitmap;	import flash.display.DisplayObject;	import flash.display.MovieClip;	import flash.display.Sprite;	import flash.display.Stage;	import flash.events.Event;	import flash.events.TimerEvent;	import flash.utils.Timer;	import KeyObject;		public class Player extends MovieClip {				[Embed(source = "images/Ness (Front).gif")]		private const playerImage:Class;		private var bitmap:Bitmap = new playerImage();				private var stageRef:Stage;		private var key:KeyObject;		private var isAirborne:Boolean = false;		private var jumpSpeedMax:int = 20		private var jumpSpeed:Number = jumpSpeedMax;		private var isGrounded:Boolean = false;		public var jumpCounter:int = 0;		public var jumpSpeedDenominator:int = 50;		public var moveCounter:int = 0;		public var moveSpeed:Number = 2.5;		private var isRightDirection:Boolean = false;		private var fireTimer:Timer;		private var canFire:Boolean = true;		public var fireCounter:int = 0;		public var _fireRate:int = 500;		private const twoSecondTimer:Timer = new Timer(2000, 1);		private var hitbox:Sprite;		private var isJumping:Boolean;				public function Player(stageRef:Stage) {			this.name = 'player';						bitmap.height = 25//37.5;			bitmap.width = 20//16.67//25;			//bitmap.y += 12.5;			this.addChild(bitmap);			/*			hitbox = new Sprite();			hitbox.graphics.beginFill(0xFFFFFF);			hitbox.graphics.drawRect(0, 12.5, 25, 25);			hitbox.graphics.endFill();			this.hitArea = hitbox;			*/			this.stageRef = stageRef;			key = new KeyObject(stageRef);						fireTimer = new Timer(_fireRate, 1);			fireTimer.addEventListener(TimerEvent.TIMER, fireTimerHandler, false, 0, true);			twoSecondTimer.addEventListener(TimerEvent.TIMER_COMPLETE, die2, false, 0, true);		}				public function startLoop():void {			this.addEventListener(Event.ENTER_FRAME, loop, false, 0, true)		}				public function endLoop():void {			this.removeEventListener(Event.ENTER_FRAME, loop);		}				private function loop(e:Event):void {			var levelRef:Sprite = stageRef.getChildByName('level') as Sprite;			var blockHolderRef:Sprite = levelRef.getChildByName('blockHolder') as Sprite; //TODO: this is just terrible						//check collisions			var currentBlock:DisplayObject;			isGrounded = false; //should create a function that returns an enumeration of part of the block it is hitting (top, bottom, left, right). Or maybe not. Should use last position to determine left, right, top, bottom.			var hittingLeftOfBlock:Boolean = false; //TODO: what if hitting corner?			var hittingRightOfBlock:Boolean = false;						//check if touching bottom of stage			if (this.y + this.height >= stageRef.height - 1) //TODO: why is stage height 401?				die();						//check block collisions			for(var i:int=0; i<blockHolderRef.numChildren; i++){				currentBlock = blockHolderRef.getChildAt(i);				currentBlock.alpha = 1;								//if move will hit box in the future, then stop moving versus moving, then moving back				//or, move one unit at a time until moveSpeed is achieved, and while moving one unit at a time, check for collisions								if (this.hitTestObject(currentBlock)) {					//trace("this.y: " + this.y + ", currentBlock.y: " + currentBlock.y);					//currentBlock.alpha = .5;					//check if hitting block from the left or right					if (this.y >= currentBlock.y && this.y < currentBlock.y + Block.height) {						//currentBlock.alpha = .5;						//trace("this.x: " + this.x + ", currentBlock.x: " + currentBlock.x);												//if (this.x < currentBlock.x + currentBlock.width/2) //left of block						if (isRightDirection) {							hittingLeftOfBlock = true;							levelRef.x += moveSpeed; //this looks terrible						}						//if (this.x + this.width > currentBlock.x + currentBlock.width/2) {//right of block						else {							hittingRightOfBlock = true;							levelRef.x -= moveSpeed; //see above						}					}										//checking if hitting above the block					else if (this.y < currentBlock.y) 						isGrounded = true;				}			}						//then we make him fall if he isn't on ground			if(!isGrounded)				isAirborne = true;											//keypresses			if ((key.isDown(key.RIGHT) || key.isDown(key.D)) && !hittingLeftOfBlock) {				levelRef.x -= moveSpeed;				moveCounter += moveSpeed;				isRightDirection = true;			}			else if ((key.isDown(key.LEFT) || key.isDown(key.A)) && !hittingRightOfBlock) {				levelRef.x += moveSpeed;				moveCounter += moveSpeed;				isRightDirection = false;			}						if ((key.isDown(key.UP) || key.isDown(key.W)) || isAirborne)				jump();			/*			bitmap.rotation = 0;			if (key.isDown(key.DOWN) || key.isDown(key.S))				bitmap.rotation = 90;			*/			if (key.isDown(key.SPACE))				fire();											if (!blockHolderRef)				return; //TODO: to avoid running the next loop before level is generated		}				private function jump():void { //TODO: clean this shit up, simplify it			if(!isAirborne) {				isAirborne = true;				jumpSpeed = jumpSpeedMax * -1;				y += jumpSpeed;								isJumping = true;				//jumpCounter++; //TODO: this counts before jumping				//moveCounter = 0; //reset move counter after jumping				return;			}						//else continue jumping if already in the air or start falling			if(jumpSpeed < 0){				jumpSpeed *= 1 - jumpSpeedMax/jumpSpeedDenominator; //20*(105/125) = 16.8, 16.8*(105/125) = ...				if(jumpSpeed > -jumpSpeedMax/5){					jumpSpeed *= -1;				}			}			else if(jumpSpeed > 0 && jumpSpeed <= jumpSpeedMax){				jumpSpeed *= 1 + jumpSpeedMax/50;			}			this.y += jumpSpeed;						//if player hits a block (either above or below), then stop jumping			//this loop will check a hit test with any block			var levelRef:Sprite = stageRef.getChildByName('level') as Sprite;			var blockHolderRef:Sprite = levelRef.getChildByName('blockHolder') as Sprite;			var currentBlock:DisplayObject;			for (var i:int = 0; i < blockHolderRef.numChildren; i++) {					currentBlock = blockHolderRef.getChildAt(i);								if (this.hitTestObject(currentBlock)) {					//hitting block from above					if(jumpSpeed > 0 && this.y < currentBlock.y) {						isGrounded = true;						isAirborne = false;						this.y = currentBlock.y - this.height;												if (isJumping) {							jumpCounter++;							moveCounter = 0;							isJumping = false;						}						break;					}					else { //TODO: if hitting a block below or SIDES!						//if jumping and hitting a block, set below the block, and start falling down						//this.y -= jumpSpeed; //currentBlock.y + currentBlock.height + 1;						jumpSpeed = Math.abs(jumpSpeed);					}				}			}					}				private function fireTimerHandler(event:TimerEvent):void {			canFire = true;		}				private function fire():void {			if(canFire) {				stageRef.addChild(new Bullet(stageRef, this.x, this.y, isRightDirection));				canFire = false;				fireTimer.start();				fireCounter++;			}		}				public function die():void {			bitmap.rotation = 90;			endLoop();			twoSecondTimer.start();		}				private function die2(event:Event):void {			var main:Main = Main.instance;			main.restartLevel(); //TODO: restart level should be done in Level						this.removeEventListener(TimerEvent.TIMER, fireTimerHandler);			this.removeEventListener(TimerEvent.TIMER_COMPLETE, die2);						if (parent)				key.deconstruct();		}				public function set fireRate(n:int):void {			_fireRate = n;			fireTimer.delay = n;		}	}}